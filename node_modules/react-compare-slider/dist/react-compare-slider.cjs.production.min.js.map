{"version":3,"file":"react-compare-slider.cjs.production.min.js","sources":["../src/ReactCompareSliderHandle.tsx","../src/utils.ts","../src/ReactCompareSlider.tsx","../src/ReactCompareSliderImage.tsx"],"sourcesContent":["import React from 'react';\n\nimport { ReactCompareSliderCommonProps } from './types';\n\ninterface ThisArrowProps {\n  /** Whether to flip the arrow direction. */\n  flip?: boolean;\n}\n\nconst ThisArrow: React.FC<ThisArrowProps> = ({ flip }) => {\n  const style: React.CSSProperties = {\n    width: 0,\n    height: 0,\n    borderTop: '8px solid transparent',\n    borderRight: '10px solid',\n    borderBottom: '8px solid transparent',\n    transform: flip ? 'rotate(180deg)' : undefined,\n  };\n\n  return <div style={style} />;\n};\n\n/** Props for `ReactCompareSliderHandle`. */\nexport interface ReactCompareSliderHandleProps\n  extends Pick<ReactCompareSliderCommonProps, 'portrait'> {\n  /** Optional styles for handle the button. */\n  buttonStyle?: React.CSSProperties;\n  /** Optional styles for lines either side of the handle button. */\n  linesStyle?: React.CSSProperties;\n  /** Optional styles for the handle root. */\n  style?: React.CSSProperties;\n}\n\n/** Default `handle`. */\nexport const ReactCompareSliderHandle: React.FC<ReactCompareSliderHandleProps> = ({\n  portrait,\n  buttonStyle,\n  linesStyle,\n  style,\n  ...props\n}): React.ReactElement => {\n  const _style: React.CSSProperties = {\n    display: 'flex',\n    flexDirection: portrait ? 'row' : 'column',\n    placeItems: 'center',\n    height: '100%',\n    cursor: portrait ? 'ns-resize' : 'ew-resize',\n    pointerEvents: 'none',\n    color: '#fff',\n    ...style,\n  };\n\n  const _linesStyle: React.CSSProperties = {\n    flexGrow: 1,\n    height: portrait ? 2 : '100%',\n    width: portrait ? '100%' : 2,\n    backgroundColor: 'currentColor',\n    pointerEvents: 'auto',\n    boxShadow: '0 0 7px rgba(0,0,0,.35)',\n    ...linesStyle,\n  };\n\n  const _buttonStyle: React.CSSProperties = {\n    display: 'grid',\n    gridAutoFlow: 'column',\n    gap: 8,\n    placeContent: 'center',\n    flexShrink: 0,\n    width: 56,\n    height: 56,\n    borderRadius: '50%',\n    borderStyle: 'solid',\n    borderWidth: 2,\n    pointerEvents: 'auto',\n    backdropFilter: 'blur(7px)',\n    boxShadow: '0 0 7px rgba(0,0,0,.35)',\n    transform: portrait ? 'rotate(90deg)' : undefined,\n    ...buttonStyle,\n  };\n\n  return (\n    <div className=\"__rcs-handle-root\" {...props} style={_style}>\n      <div className=\"__rcs-handle-line\" style={_linesStyle} />\n      <div className=\"__rcs-handle-button\" style={_buttonStyle}>\n        <ThisArrow />\n        <ThisArrow flip />\n      </div>\n      <div className=\"__rcs-handle-line\" style={_linesStyle} />\n    </div>\n  );\n};\n","import { RefObject, useCallback, useEffect, useLayoutEffect, useRef } from 'react';\n\n/**\n * Stand-alone CSS utility to make replaced elements (`img`, `video`, etc.) fit their\n * container.\n */\nexport const styleFitContainer = ({\n  boxSizing = 'border-box',\n  objectFit = 'cover',\n  objectPosition = 'center',\n  ...props\n}: React.CSSProperties = {}): React.CSSProperties => ({\n  display: 'block',\n  width: '100%',\n  height: '100%',\n  maxWidth: '100%',\n  boxSizing,\n  objectFit,\n  objectPosition,\n  ...props,\n});\n\n/** Store the previous supplied value. */\nexport const usePrevious = <T>(value: T): T => {\n  const ref = useRef<T>(value);\n\n  useEffect(() => {\n    ref.current = value;\n  });\n\n  return ref.current;\n};\n\n/**\n * Event listener binding hook.\n * @param eventName      - Event to bind to.\n * @param handler        - Callback handler.\n * @param element        - Element to bind to.\n * @param handlerOptions - Event handler options.\n */\nexport const useEventListener = (\n  eventName: EventListener['name'],\n  handler: EventListener['caller'],\n  element: EventTarget,\n  handlerOptions: AddEventListenerOptions\n): void => {\n  const savedHandler = useRef<EventListener['caller']>();\n\n  useEffect(() => {\n    savedHandler.current = handler;\n  }, [handler]);\n\n  useEffect(() => {\n    // Make sure element supports addEventListener.\n    if (!(element && element.addEventListener)) return;\n\n    // Create event listener that calls handler function stored in ref.\n    const eventListener: EventListener = (event) =>\n      savedHandler.current && savedHandler.current(event);\n\n    element.addEventListener(eventName, eventListener, handlerOptions);\n\n    return (): void => {\n      element.removeEventListener(eventName, eventListener, handlerOptions);\n    };\n  }, [eventName, element, handlerOptions]);\n};\n\n/**\n * Conditionally use `useLayoutEffect` for client *or* `useEffect` for SSR.\n * @see <https://github.com/reduxjs/react-redux/blob/c581d480dd675f2645851fb006bef91aeb6ac24d/src/utils/useIsomorphicLayoutEffect.js>\n */\nexport const useIsomorphicLayoutEffect =\n  typeof window !== 'undefined' && window.document && window.document.createElement\n    ? useLayoutEffect\n    : useEffect;\n\n/** Params passed to `useResizeObserver` `handler` function. */\nexport type UseResizeObserverHandlerParams = DOMRect;\n\n/**\n * Bind resize observer callback to element.\n * @param ref       - Element to bind to.\n * @param handler   - Callback for handling entry's bounding rect.\n */\nexport const useResizeObserver = (\n  ref: RefObject<Element>,\n  handler: (entry: UseResizeObserverHandlerParams) => void\n): void => {\n  const observer = useRef<ResizeObserver>();\n\n  const observe = useCallback(() => {\n    if (ref.current && observer.current) observer.current.observe(ref.current);\n  }, [ref]);\n\n  // Bind/rebind observer when `handler` changes.\n  useIsomorphicLayoutEffect(() => {\n    observer.current = new ResizeObserver(([entry]) => handler(entry.contentRect));\n    observe();\n\n    return (): void => {\n      if (observer.current) observer.current.disconnect();\n    };\n  }, [handler, observe]);\n};\n","import React, { forwardRef, useEffect, useCallback, useRef, useState } from 'react';\n\nimport { ReactCompareSliderHandle } from './ReactCompareSliderHandle';\nimport { ReactCompareSliderCommonProps, ReactCompareSliderPropPosition } from './types';\n\nimport {\n  useEventListener,\n  usePrevious,\n  UseResizeObserverHandlerParams,\n  useResizeObserver,\n} from './utils';\n\n/** Container for clipped item. */\nconst ThisClipContainer = forwardRef<HTMLDivElement, React.HTMLProps<HTMLDivElement>>(\n  (props, ref): React.ReactElement => {\n    const style: React.CSSProperties = {\n      position: 'absolute',\n      top: 0,\n      left: 0,\n      width: '100%',\n      height: '100%',\n      willChange: 'clip',\n      userSelect: 'none',\n      KhtmlUserSelect: 'none',\n      MozUserSelect: 'none',\n      WebkitUserSelect: 'none',\n    };\n\n    return <div {...props} style={style} data-rcs=\"clip-item\" ref={ref} />;\n  }\n);\n\nThisClipContainer.displayName = 'ThisClipContainer';\n\n/** Handle container to control position. */\nconst ThisHandleContainer = forwardRef<\n  HTMLDivElement,\n  React.HTMLProps<HTMLDivElement> & Pick<ReactCompareSliderCommonProps, 'portrait'>\n>(\n  ({ children, portrait }, ref): React.ReactElement => {\n    const style: React.CSSProperties = {\n      position: 'absolute',\n      top: 0,\n      width: '100%',\n      height: '100%',\n      pointerEvents: 'none',\n    };\n\n    const innerStyle: React.CSSProperties = {\n      position: 'absolute',\n      width: portrait ? '100%' : undefined,\n      height: portrait ? undefined : '100%',\n      transform: portrait ? 'translateY(-50%)' : 'translateX(-50%)',\n      pointerEvents: 'all',\n    };\n\n    return (\n      <div style={style} data-rcs=\"handle-container\" ref={ref}>\n        <div style={innerStyle}>{children}</div>\n      </div>\n    );\n  }\n);\n\nThisHandleContainer.displayName = 'ThisHandleContainer';\n\n/** Comparison slider properties. */\nexport interface ReactCompareSliderProps extends Partial<ReactCompareSliderCommonProps> {\n  /** Padding to limit the slideable bounds in pixels on the X-axis (landscape) or Y-axis (portrait). */\n  boundsPadding?: number;\n  /** Custom handle component. */\n  handle?: React.ReactNode;\n  /** First item to show. */\n  itemOne: React.ReactNode;\n  /** Second item to show. */\n  itemTwo: React.ReactNode;\n  /** Whether to only change position when handle is interacted with (useful for touch devices). */\n  onlyHandleDraggable?: boolean;\n  /** Callback on position change with position as percentage. */\n  onPositionChange?: (position: ReactCompareSliderPropPosition) => void;\n}\n\n/** Properties for internal `updateInternalPosition` callback. */\ninterface UpdateInternalPositionProps\n  extends Required<Pick<ReactCompareSliderProps, 'boundsPadding' | 'portrait'>> {\n  /** X coordinate to update to (landscape). */\n  x: number;\n  /** Y coordinate to update to (portrait). */\n  y: number;\n  /** Whether to calculate using page X and Y offsets (required for pointer events). */\n  isOffset?: boolean;\n}\n\nconst EVENT_PASSIVE_PARAMS = { passive: true };\nconst EVENT_CAPTURE_PARAMS = { capture: true, passive: false };\n\n/** Root Comparison slider. */\nexport const ReactCompareSlider: React.FC<\n  ReactCompareSliderProps & React.HtmlHTMLAttributes<HTMLDivElement>\n> = ({\n  handle,\n  itemOne,\n  itemTwo,\n  onlyHandleDraggable = false,\n  onPositionChange,\n  portrait = false,\n  position = 50,\n  boundsPadding = 0,\n  style,\n  ...props\n}): React.ReactElement => {\n  /** Reference to root container. */\n  const rootContainerRef = useRef<HTMLDivElement>(null);\n  /** Reference to clip container. */\n  const clipContainerRef = useRef<HTMLDivElement>(null);\n  /** Reference to handle container. */\n  const handleContainerRef = useRef<HTMLDivElement>(null);\n  /** Reference to current position as a percentage value. */\n  const internalPositionPc = useRef(position);\n  /** Previous `position` prop value. */\n  const prevPropPosition = usePrevious(position);\n  /** Whether user is currently dragging. */\n  const [isDragging, setIsDragging] = useState(false);\n  /** Whether component has a `window` event binding. */\n  const hasWindowBinding = useRef(false);\n  /** Target container for pointer events. */\n  const [interactiveTarget, setInteractiveTarget] = useState<HTMLDivElement | null>();\n\n  // Set target container for pointer events.\n  useEffect(() => {\n    setInteractiveTarget(\n      onlyHandleDraggable ? handleContainerRef.current : rootContainerRef.current\n    );\n  }, [onlyHandleDraggable]);\n\n  /** Update internal position value. */\n  const updateInternalPosition = useCallback(\n    function updateInternalCall({\n      x,\n      y,\n      isOffset,\n      portrait: _portrait,\n      boundsPadding: _boundsPadding,\n    }: UpdateInternalPositionProps) {\n      const {\n        top,\n        left,\n        width,\n        height,\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      } = rootContainerRef.current!.getBoundingClientRect();\n\n      // Early out if width or height are zero, can't calculate values\n      // from zeros.\n      if (width === 0 || height === 0) return;\n\n      // Clamp pixel position to always be within the container's bounds.\n      // This does *not* take `boundsPadding` into account because we need\n      // the real coords to correctly position the handle.\n      const positionPx = Math.min(\n        Math.max(\n          // Determine bounds based on orientation\n          _portrait\n            ? isOffset\n              ? y - top - window.pageYOffset\n              : y\n            : isOffset\n            ? x - left - window.pageXOffset\n            : x,\n          // Min value\n          0\n        ),\n        // Max value\n        _portrait ? height : width\n      );\n\n      /**\n       * Internal position percentage *without* bounds.\n       * @NOTE This uses the entire container bounds **without** `boundsPadding`\n       *       to get the *real* bounds.\n       */\n      const nextInternalPositionPc = (positionPx / (_portrait ? height : width)) * 100;\n\n      /** Determine if the current pixel position meets the min/max bounds. */\n      const positionMeetsBounds = _portrait\n        ? positionPx === 0 || positionPx === height\n        : positionPx === 0 || positionPx === width;\n\n      const canSkipPositionPc =\n        nextInternalPositionPc === internalPositionPc.current &&\n        (internalPositionPc.current === 0 || internalPositionPc.current === 100);\n\n      // Early out if pixel and percentage positions are already at the min/max\n      // to prevent update spamming when the user is sliding outside of the\n      // container.\n      if (canSkipPositionPc && positionMeetsBounds) {\n        return;\n      }\n\n      // Set new internal position.\n      internalPositionPc.current = nextInternalPositionPc;\n\n      /** Pixel position clamped to extremities *with* bounds padding. */\n      const clampedPx = Math.min(\n        // Get largest from pixel position *or* bounds padding.\n        Math.max(positionPx, 0 + _boundsPadding),\n        // Use height *or* width based on orientation.\n        (_portrait ? height : width) - _boundsPadding\n      );\n\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      clipContainerRef.current!.style.clip = _portrait\n        ? `rect(auto,auto,${clampedPx}px,auto)`\n        : `rect(auto,${clampedPx}px,auto,auto)`;\n\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      handleContainerRef.current!.style.transform = _portrait\n        ? `translate3d(0,${clampedPx}px,0)`\n        : `translate3d(${clampedPx}px,0,0)`;\n\n      if (onPositionChange) onPositionChange(internalPositionPc.current);\n    },\n    [onPositionChange]\n  );\n\n  // Update internal position when other user controllable props change.\n  useEffect(() => {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const { width, height } = rootContainerRef.current!.getBoundingClientRect();\n\n    // Use current internal position if `position` hasn't changed.\n    const nextPosition =\n      position === prevPropPosition ? internalPositionPc.current : position;\n\n    updateInternalPosition({\n      portrait,\n      boundsPadding,\n      x: (width / 100) * nextPosition,\n      y: (height / 100) * nextPosition,\n    });\n  }, [portrait, position, prevPropPosition, boundsPadding, updateInternalPosition]);\n\n  /** Handle mouse/touch down. */\n  const handlePointerDown = useCallback(\n    (ev: MouseEvent | TouchEvent) => {\n      ev.preventDefault();\n\n      updateInternalPosition({\n        portrait,\n        boundsPadding,\n        isOffset: true,\n        x: ev instanceof MouseEvent ? ev.pageX : ev.touches[0].pageX,\n        y: ev instanceof MouseEvent ? ev.pageY : ev.touches[0].pageY,\n      });\n\n      setIsDragging(true);\n    },\n    [portrait, boundsPadding, updateInternalPosition]\n  );\n\n  /** Handle mouse/touch move. */\n  const handlePointerMove = useCallback(\n    function moveCall(ev: MouseEvent | TouchEvent) {\n      updateInternalPosition({\n        portrait,\n        boundsPadding,\n        isOffset: true,\n        x: ev instanceof MouseEvent ? ev.pageX : ev.touches[0].pageX,\n        y: ev instanceof MouseEvent ? ev.pageY : ev.touches[0].pageY,\n      });\n    },\n    [portrait, boundsPadding, updateInternalPosition]\n  );\n\n  /** Handle mouse/touch up. */\n  const handlePointerUp = useCallback(() => {\n    setIsDragging(false);\n  }, []);\n\n  /** Resync internal position on resize. */\n  const handleResize = useCallback(\n    ({ width, height }: UseResizeObserverHandlerParams) => {\n      updateInternalPosition({\n        portrait,\n        boundsPadding,\n        x: (width / 100) * internalPositionPc.current,\n        y: (height / 100) * internalPositionPc.current,\n      });\n    },\n    [portrait, boundsPadding, updateInternalPosition]\n  );\n\n  // Allow drag outside of container while pointer is still down.\n  useEffect(() => {\n    if (isDragging && !hasWindowBinding.current) {\n      window.addEventListener('mousemove', handlePointerMove, EVENT_PASSIVE_PARAMS);\n      window.addEventListener('mouseup', handlePointerUp, EVENT_PASSIVE_PARAMS);\n      window.addEventListener('touchmove', handlePointerMove, EVENT_PASSIVE_PARAMS);\n      window.addEventListener('touchend', handlePointerUp, EVENT_PASSIVE_PARAMS);\n      hasWindowBinding.current = true;\n    }\n\n    return (): void => {\n      if (hasWindowBinding.current) {\n        window.removeEventListener('mousemove', handlePointerMove);\n        window.removeEventListener('mouseup', handlePointerUp);\n        window.removeEventListener('touchmove', handlePointerMove);\n        window.removeEventListener('touchend', handlePointerUp);\n        hasWindowBinding.current = false;\n      }\n    };\n  }, [handlePointerMove, handlePointerUp, isDragging]);\n\n  // Bind resize observer to container.\n  useResizeObserver(rootContainerRef, handleResize);\n\n  useEventListener(\n    'mousedown',\n    handlePointerDown,\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    interactiveTarget!,\n    EVENT_CAPTURE_PARAMS\n  );\n\n  useEventListener(\n    'touchstart',\n    handlePointerDown,\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    interactiveTarget!,\n    EVENT_CAPTURE_PARAMS\n  );\n\n  // Use custom handle if requested.\n  const Handle = handle || <ReactCompareSliderHandle portrait={portrait} />;\n\n  const rootStyle: React.CSSProperties = {\n    position: 'relative',\n    overflow: 'hidden',\n    cursor: isDragging ? (portrait ? 'ns-resize' : 'ew-resize') : undefined,\n    userSelect: 'none',\n    KhtmlUserSelect: 'none',\n    msUserSelect: 'none',\n    MozUserSelect: 'none',\n    WebkitUserSelect: 'none',\n    ...style,\n  };\n\n  return (\n    <div {...props} ref={rootContainerRef} style={rootStyle} data-rcs=\"root\">\n      {itemTwo}\n      <ThisClipContainer ref={clipContainerRef}>{itemOne}</ThisClipContainer>\n      <ThisHandleContainer portrait={portrait} ref={handleContainerRef}>\n        {Handle}\n      </ThisHandleContainer>\n    </div>\n  );\n};\n","import React from 'react';\n\nimport { styleFitContainer } from './utils';\n\n/** Props for `ReactCompareSliderImage`. */\nexport type ReactCompareSliderImageProps = React.ImgHTMLAttributes<HTMLImageElement>;\n\n/** Image with defaults from `styleFitContainer` applied. */\nexport const ReactCompareSliderImage: React.FC<ReactCompareSliderImageProps> = ({\n  style,\n  ...props\n}): React.ReactElement => {\n  const rootStyle: React.CSSProperties = styleFitContainer(style);\n\n  return <img {...props} style={rootStyle} data-rcs=\"image\" />;\n};\n"],"names":["ThisArrow","flip","React","style","width","height","borderTop","borderRight","borderBottom","transform","undefined","ReactCompareSliderHandle","portrait","buttonStyle","linesStyle","props","_style","display","flexDirection","placeItems","cursor","pointerEvents","color","_linesStyle","flexGrow","backgroundColor","boxShadow","_buttonStyle","gridAutoFlow","gap","placeContent","flexShrink","borderRadius","borderStyle","borderWidth","backdropFilter","className","styleFitContainer","boxSizing","objectFit","objectPosition","maxWidth","useEventListener","eventName","handler","element","handlerOptions","savedHandler","useRef","useEffect","current","addEventListener","eventListener","event","removeEventListener","useIsomorphicLayoutEffect","window","document","createElement","useLayoutEffect","ThisClipContainer","forwardRef","ref","position","top","left","willChange","userSelect","KhtmlUserSelect","MozUserSelect","WebkitUserSelect","displayName","ThisHandleContainer","children","EVENT_PASSIVE_PARAMS","passive","EVENT_CAPTURE_PARAMS","capture","handle","itemOne","itemTwo","onlyHandleDraggable","onPositionChange","boundsPadding","rootContainerRef","clipContainerRef","handleContainerRef","internalPositionPc","prevPropPosition","value","usePrevious","isDragging","setIsDragging","useState","hasWindowBinding","interactiveTarget","setInteractiveTarget","updateInternalPosition","useCallback","x","y","isOffset","_portrait","_boundsPadding","getBoundingClientRect","positionPx","Math","min","max","pageYOffset","pageXOffset","nextInternalPositionPc","clampedPx","clip","nextPosition","handlePointerDown","ev","preventDefault","MouseEvent","pageX","touches","pageY","handlePointerMove","handlePointerUp","handleResize","observer","observe","ResizeObserver","entry","contentRect","disconnect","useResizeObserver","Handle","rootStyle","overflow","msUserSelect"],"mappings":"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"}