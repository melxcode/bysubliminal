{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport * as React from 'react';\nimport clsx from 'clsx';\nimport PropTypes from 'prop-types';\nimport { experimentalStyled, useTheme, unstable_useThemeProps as useThemeProps } from '@material-ui/core/styles';\nimport { unstable_composeClasses as composeClasses } from '@material-ui/unstyled';\nimport { useControlled, useForkRef, ownerDocument, unstable_useId as useId } from '@material-ui/core/utils';\nimport TreeViewContext from './TreeViewContext';\nimport { DescendantProvider } from './descendants';\nimport { getTreeViewUtilityClass } from './treeViewClasses';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\n\nconst overridesResolver = (props, styles) => styles.root || {};\n\nconst useUtilityClasses = styleProps => {\n  const {\n    classes\n  } = styleProps;\n  const slots = {\n    root: ['root']\n  };\n  return composeClasses(slots, getTreeViewUtilityClass, classes);\n};\n\nconst TreeViewRoot = experimentalStyled('ul', {}, {\n  name: 'MuiTreeView',\n  slot: 'Root',\n  overridesResolver\n})({\n  padding: 0,\n  margin: 0,\n  listStyle: 'none',\n  outline: 0\n});\n\nfunction isPrintableCharacter(string) {\n  return string && string.length === 1 && string.match(/\\S/);\n}\n\nfunction findNextFirstChar(firstChars, startIndex, char) {\n  for (let i = startIndex; i < firstChars.length; i += 1) {\n    if (char === firstChars[i]) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\nfunction noopSelection() {\n  return false;\n}\n\nconst defaultDefaultExpanded = [];\nconst defaultDefaultSelected = [];\nconst TreeView = /*#__PURE__*/React.forwardRef(function TreeView(inProps, ref) {\n  const props = useThemeProps({\n    props: inProps,\n    name: 'MuiTreeView'\n  });\n\n  const {\n    children,\n    className,\n    defaultCollapseIcon,\n    defaultEndIcon,\n    defaultExpanded = defaultDefaultExpanded,\n    defaultExpandIcon,\n    defaultParentIcon,\n    defaultSelected = defaultDefaultSelected,\n    disabledItemsFocusable = false,\n    disableSelection = false,\n    expanded: expandedProp,\n    id: idProp,\n    multiSelect = false,\n    onBlur,\n    onFocus,\n    onKeyDown,\n    onNodeFocus,\n    onNodeSelect,\n    onNodeToggle,\n    selected: selectedProp\n  } = props,\n        other = _objectWithoutPropertiesLoose(props, [\"children\", \"className\", \"defaultCollapseIcon\", \"defaultEndIcon\", \"defaultExpanded\", \"defaultExpandIcon\", \"defaultParentIcon\", \"defaultSelected\", \"disabledItemsFocusable\", \"disableSelection\", \"expanded\", \"id\", \"multiSelect\", \"onBlur\", \"onFocus\", \"onKeyDown\", \"onNodeFocus\", \"onNodeSelect\", \"onNodeToggle\", \"selected\"]); // use the `isRtl` from the props after the buildAPI script support it\n\n\n  const theme = useTheme();\n  const isRtl = theme.direction === 'rtl';\n\n  const styleProps = _extends({}, props, {\n    defaultExpanded,\n    defaultSelected,\n    disabledItemsFocusable,\n    disableSelection,\n    multiSelect\n  });\n\n  const classes = useUtilityClasses(styleProps);\n  const treeId = useId(idProp);\n  const treeRef = React.useRef(null);\n  const handleRef = useForkRef(treeRef, ref);\n  const [focusedNodeId, setFocusedNodeId] = React.useState(null);\n  const nodeMap = React.useRef({});\n  const firstCharMap = React.useRef({});\n  const [expanded, setExpandedState] = useControlled({\n    controlled: expandedProp,\n    default: defaultExpanded,\n    name: 'TreeView',\n    state: 'expanded'\n  });\n  const [selected, setSelectedState] = useControlled({\n    controlled: selectedProp,\n    default: defaultSelected,\n    name: 'TreeView',\n    state: 'selected'\n  });\n  /*\n   * Status Helpers\n   */\n\n  const isExpanded = React.useCallback(id => Array.isArray(expanded) ? expanded.indexOf(id) !== -1 : false, [expanded]);\n  const isExpandable = React.useCallback(id => nodeMap.current[id] && nodeMap.current[id].expandable, []);\n  const isSelected = React.useCallback(id => Array.isArray(selected) ? selected.indexOf(id) !== -1 : selected === id, [selected]);\n  const isDisabled = React.useCallback(id => {\n    let node = nodeMap.current[id]; // This can be called before the node has been added to the node map.\n\n    if (!node) {\n      return false;\n    }\n\n    if (node.disabled) {\n      return true;\n    }\n\n    while (node.parentId != null) {\n      node = nodeMap.current[node.parentId];\n\n      if (node.disabled) {\n        return true;\n      }\n    }\n\n    return false;\n  }, []);\n\n  const isFocused = id => focusedNodeId === id;\n  /*\n   * Child Helpers\n   */\n  // Using Object.keys -> .map to mimic Object.values we should replace with Object.values() once we stop IE11 support.\n\n\n  const getChildrenIds = id => Object.keys(nodeMap.current).map(key => {\n    return nodeMap.current[key];\n  }).filter(node => node.parentId === id).sort((a, b) => a.index - b.index).map(child => child.id);\n\n  const getNavigableChildrenIds = id => {\n    let childrenIds = getChildrenIds(id);\n\n    if (!disabledItemsFocusable) {\n      childrenIds = childrenIds.filter(node => !isDisabled(node));\n    }\n\n    return childrenIds;\n  };\n  /*\n   * Node Helpers\n   */\n\n\n  const getNextNode = id => {\n    // If expanded get first child\n    if (isExpanded(id) && getNavigableChildrenIds(id).length > 0) {\n      return getNavigableChildrenIds(id)[0];\n    } // Try to get next sibling\n\n\n    const node = nodeMap.current[id];\n    const siblings = getNavigableChildrenIds(node.parentId);\n    const nextSibling = siblings[siblings.indexOf(id) + 1];\n\n    if (nextSibling) {\n      return nextSibling;\n    } // try to get parent's next sibling\n\n\n    const parent = nodeMap.current[node.parentId];\n\n    if (parent) {\n      const parentSiblings = getNavigableChildrenIds(parent.parentId);\n      return parentSiblings[parentSiblings.indexOf(parent.id) + 1];\n    }\n\n    return null;\n  };\n\n  const getPreviousNode = id => {\n    const node = nodeMap.current[id];\n    const siblings = getNavigableChildrenIds(node.parentId);\n    const nodeIndex = siblings.indexOf(id);\n\n    if (nodeIndex === 0) {\n      return node.parentId;\n    }\n\n    let currentNode = siblings[nodeIndex - 1];\n\n    while (isExpanded(currentNode) && getNavigableChildrenIds(currentNode).length > 0) {\n      currentNode = getNavigableChildrenIds(currentNode).pop();\n    }\n\n    return currentNode;\n  };\n\n  const getLastNode = () => {\n    let lastNode = getNavigableChildrenIds(null).pop();\n\n    while (isExpanded(lastNode)) {\n      lastNode = getNavigableChildrenIds(lastNode).pop();\n    }\n\n    return lastNode;\n  };\n\n  const getFirstNode = () => getNavigableChildrenIds(null)[0];\n\n  const getParent = id => nodeMap.current[id].parentId;\n  /**\n   * This is used to determine the start and end of a selection range so\n   * we can get the nodes between the two border nodes.\n   *\n   * It finds the nodes' common ancestor using\n   * a naive implementation of a lowest common ancestor algorithm\n   * (https://en.wikipedia.org/wiki/Lowest_common_ancestor).\n   * Then compares the ancestor's 2 children that are ancestors of nodeA and NodeB\n   * so we can compare their indexes to work out which node comes first in a depth first search.\n   * (https://en.wikipedia.org/wiki/Depth-first_search)\n   *\n   * Another way to put it is which node is shallower in a trÃ©maux tree\n   * https://en.wikipedia.org/wiki/Tr%C3%A9maux_tree\n   */\n\n\n  const findOrderInTremauxTree = (nodeAId, nodeBId) => {\n    if (nodeAId === nodeBId) {\n      return [nodeAId, nodeBId];\n    }\n\n    const nodeA = nodeMap.current[nodeAId];\n    const nodeB = nodeMap.current[nodeBId];\n\n    if (nodeA.parentId === nodeB.id || nodeB.parentId === nodeA.id) {\n      return nodeB.parentId === nodeA.id ? [nodeA.id, nodeB.id] : [nodeB.id, nodeA.id];\n    }\n\n    const aFamily = [nodeA.id];\n    const bFamily = [nodeB.id];\n    let aAncestor = nodeA.parentId;\n    let bAncestor = nodeB.parentId;\n    let aAncestorIsCommon = bFamily.indexOf(aAncestor) !== -1;\n    let bAncestorIsCommon = aFamily.indexOf(bAncestor) !== -1;\n    let continueA = true;\n    let continueB = true;\n\n    while (!bAncestorIsCommon && !aAncestorIsCommon) {\n      if (continueA) {\n        aFamily.push(aAncestor);\n        aAncestorIsCommon = bFamily.indexOf(aAncestor) !== -1;\n        continueA = aAncestor !== null;\n\n        if (!aAncestorIsCommon && continueA) {\n          aAncestor = nodeMap.current[aAncestor].parentId;\n        }\n      }\n\n      if (continueB && !aAncestorIsCommon) {\n        bFamily.push(bAncestor);\n        bAncestorIsCommon = aFamily.indexOf(bAncestor) !== -1;\n        continueB = bAncestor !== null;\n\n        if (!bAncestorIsCommon && continueB) {\n          bAncestor = nodeMap.current[bAncestor].parentId;\n        }\n      }\n    }\n\n    const commonAncestor = aAncestorIsCommon ? aAncestor : bAncestor;\n    const ancestorFamily = getChildrenIds(commonAncestor);\n    const aSide = aFamily[aFamily.indexOf(commonAncestor) - 1];\n    const bSide = bFamily[bFamily.indexOf(commonAncestor) - 1];\n    return ancestorFamily.indexOf(aSide) < ancestorFamily.indexOf(bSide) ? [nodeAId, nodeBId] : [nodeBId, nodeAId];\n  };\n\n  const getNodesInRange = (nodeA, nodeB) => {\n    const [first, last] = findOrderInTremauxTree(nodeA, nodeB);\n    const nodes = [first];\n    let current = first;\n\n    while (current !== last) {\n      current = getNextNode(current);\n      nodes.push(current);\n    }\n\n    return nodes;\n  };\n  /*\n   * Focus Helpers\n   */\n\n\n  const focus = (event, id) => {\n    if (id) {\n      setFocusedNodeId(id);\n\n      if (onNodeFocus) {\n        onNodeFocus(event, id);\n      }\n    }\n  };\n\n  const focusNextNode = (event, id) => focus(event, getNextNode(id));\n\n  const focusPreviousNode = (event, id) => focus(event, getPreviousNode(id));\n\n  const focusFirstNode = event => focus(event, getFirstNode());\n\n  const focusLastNode = event => focus(event, getLastNode());\n\n  const focusByFirstCharacter = (event, id, char) => {\n    let start;\n    let index;\n    const lowercaseChar = char.toLowerCase();\n    const firstCharIds = [];\n    const firstChars = []; // This really only works since the ids are strings\n\n    Object.keys(firstCharMap.current).forEach(nodeId => {\n      const firstChar = firstCharMap.current[nodeId];\n      const map = nodeMap.current[nodeId];\n      const visible = map.parentId ? isExpanded(map.parentId) : true;\n      const shouldBeSkipped = disabledItemsFocusable ? false : isDisabled(nodeId);\n\n      if (visible && !shouldBeSkipped) {\n        firstCharIds.push(nodeId);\n        firstChars.push(firstChar);\n      }\n    }); // Get start index for search based on position of currentItem\n\n    start = firstCharIds.indexOf(id) + 1;\n\n    if (start >= firstCharIds.length) {\n      start = 0;\n    } // Check remaining slots in the menu\n\n\n    index = findNextFirstChar(firstChars, start, lowercaseChar); // If not found in remaining slots, check from beginning\n\n    if (index === -1) {\n      index = findNextFirstChar(firstChars, 0, lowercaseChar);\n    } // If match was found...\n\n\n    if (index > -1) {\n      focus(event, firstCharIds[index]);\n    }\n  };\n  /*\n   * Expansion Helpers\n   */\n\n\n  const toggleExpansion = (event, value = focusedNodeId) => {\n    let newExpanded;\n\n    if (expanded.indexOf(value) !== -1) {\n      newExpanded = expanded.filter(id => id !== value);\n    } else {\n      newExpanded = [value].concat(expanded);\n    }\n\n    if (onNodeToggle) {\n      onNodeToggle(event, newExpanded);\n    }\n\n    setExpandedState(newExpanded);\n  };\n\n  const expandAllSiblings = (event, id) => {\n    const map = nodeMap.current[id];\n    const siblings = getChildrenIds(map.parentId);\n    const diff = siblings.filter(child => isExpandable(child) && !isExpanded(child));\n    const newExpanded = expanded.concat(diff);\n\n    if (diff.length > 0) {\n      setExpandedState(newExpanded);\n\n      if (onNodeToggle) {\n        onNodeToggle(event, newExpanded);\n      }\n    }\n  };\n  /*\n   * Selection Helpers\n   */\n\n\n  const lastSelectedNode = React.useRef(null);\n  const lastSelectionWasRange = React.useRef(false);\n  const currentRangeSelection = React.useRef([]);\n\n  const handleRangeArrowSelect = (event, nodes) => {\n    let base = selected.slice();\n    const {\n      start,\n      next,\n      current\n    } = nodes;\n\n    if (!next || !current) {\n      return;\n    }\n\n    if (currentRangeSelection.current.indexOf(current) === -1) {\n      currentRangeSelection.current = [];\n    }\n\n    if (lastSelectionWasRange.current) {\n      if (currentRangeSelection.current.indexOf(next) !== -1) {\n        base = base.filter(id => id === start || id !== current);\n        currentRangeSelection.current = currentRangeSelection.current.filter(id => id === start || id !== current);\n      } else {\n        base.push(next);\n        currentRangeSelection.current.push(next);\n      }\n    } else {\n      base.push(next);\n      currentRangeSelection.current.push(current, next);\n    }\n\n    if (onNodeSelect) {\n      onNodeSelect(event, base);\n    }\n\n    setSelectedState(base);\n  };\n\n  const handleRangeSelect = (event, nodes) => {\n    let base = selected.slice();\n    const {\n      start,\n      end\n    } = nodes; // If last selection was a range selection ignore nodes that were selected.\n\n    if (lastSelectionWasRange.current) {\n      base = base.filter(id => currentRangeSelection.current.indexOf(id) === -1);\n    }\n\n    let range = getNodesInRange(start, end);\n    range = range.filter(node => !isDisabled(node));\n    currentRangeSelection.current = range;\n    let newSelected = base.concat(range);\n    newSelected = newSelected.filter((id, i) => newSelected.indexOf(id) === i);\n\n    if (onNodeSelect) {\n      onNodeSelect(event, newSelected);\n    }\n\n    setSelectedState(newSelected);\n  };\n\n  const handleMultipleSelect = (event, value) => {\n    let newSelected;\n\n    if (selected.indexOf(value) !== -1) {\n      newSelected = selected.filter(id => id !== value);\n    } else {\n      newSelected = [value].concat(selected);\n    }\n\n    if (onNodeSelect) {\n      onNodeSelect(event, newSelected);\n    }\n\n    setSelectedState(newSelected);\n  };\n\n  const handleSingleSelect = (event, value) => {\n    const newSelected = multiSelect ? [value] : value;\n\n    if (onNodeSelect) {\n      onNodeSelect(event, newSelected);\n    }\n\n    setSelectedState(newSelected);\n  };\n\n  const selectNode = (event, id, multiple = false) => {\n    if (id) {\n      if (multiple) {\n        handleMultipleSelect(event, id);\n      } else {\n        handleSingleSelect(event, id);\n      }\n\n      lastSelectedNode.current = id;\n      lastSelectionWasRange.current = false;\n      currentRangeSelection.current = [];\n      return true;\n    }\n\n    return false;\n  };\n\n  const selectRange = (event, nodes, stacked = false) => {\n    const {\n      start = lastSelectedNode.current,\n      end,\n      current\n    } = nodes;\n\n    if (stacked) {\n      handleRangeArrowSelect(event, {\n        start,\n        next: end,\n        current\n      });\n    } else if (start != null && end != null) {\n      handleRangeSelect(event, {\n        start,\n        end\n      });\n    }\n\n    lastSelectionWasRange.current = true;\n  };\n\n  const rangeSelectToFirst = (event, id) => {\n    if (!lastSelectedNode.current) {\n      lastSelectedNode.current = id;\n    }\n\n    const start = lastSelectionWasRange.current ? lastSelectedNode.current : id;\n    selectRange(event, {\n      start,\n      end: getFirstNode()\n    });\n  };\n\n  const rangeSelectToLast = (event, id) => {\n    if (!lastSelectedNode.current) {\n      lastSelectedNode.current = id;\n    }\n\n    const start = lastSelectionWasRange.current ? lastSelectedNode.current : id;\n    selectRange(event, {\n      start,\n      end: getLastNode()\n    });\n  };\n\n  const selectNextNode = (event, id) => {\n    if (!isDisabled(getNextNode(id))) {\n      selectRange(event, {\n        end: getNextNode(id),\n        current: id\n      }, true);\n    }\n  };\n\n  const selectPreviousNode = (event, id) => {\n    if (!isDisabled(getPreviousNode(id))) {\n      selectRange(event, {\n        end: getPreviousNode(id),\n        current: id\n      }, true);\n    }\n  };\n\n  const selectAllNodes = event => {\n    selectRange(event, {\n      start: getFirstNode(),\n      end: getLastNode()\n    });\n  };\n  /*\n   * Mapping Helpers\n   */\n\n\n  const registerNode = React.useCallback(node => {\n    const {\n      id,\n      index,\n      parentId,\n      expandable,\n      idAttribute,\n      disabled\n    } = node;\n    nodeMap.current[id] = {\n      id,\n      index,\n      parentId,\n      expandable,\n      idAttribute,\n      disabled\n    };\n  }, []);\n  const unregisterNode = React.useCallback(id => {\n    const newMap = _extends({}, nodeMap.current);\n\n    delete newMap[id];\n    nodeMap.current = newMap;\n    setFocusedNodeId(oldFocusedNodeId => {\n      if (oldFocusedNodeId === id && treeRef.current === ownerDocument(treeRef.current).activeElement) {\n        return getChildrenIds(null)[0];\n      }\n\n      return oldFocusedNodeId;\n    });\n  }, []);\n  const mapFirstChar = React.useCallback((id, firstChar) => {\n    firstCharMap.current[id] = firstChar;\n  }, []);\n  const unMapFirstChar = React.useCallback(id => {\n    const newMap = _extends({}, firstCharMap.current);\n\n    delete newMap[id];\n    firstCharMap.current = newMap;\n  }, []);\n  /**\n   * Event handlers and Navigation\n   */\n\n  const handleNextArrow = event => {\n    if (isExpandable(focusedNodeId)) {\n      if (isExpanded(focusedNodeId)) {\n        focusNextNode(event, focusedNodeId);\n      } else if (!isDisabled(focusedNodeId)) {\n        toggleExpansion(event);\n      }\n    }\n\n    return true;\n  };\n\n  const handlePreviousArrow = event => {\n    if (isExpanded(focusedNodeId) && !isDisabled(focusedNodeId)) {\n      toggleExpansion(event, focusedNodeId);\n      return true;\n    }\n\n    const parent = getParent(focusedNodeId);\n\n    if (parent) {\n      focus(event, parent);\n      return true;\n    }\n\n    return false;\n  };\n\n  const handleKeyDown = event => {\n    let flag = false;\n    const key = event.key; // If the tree is empty there will be no focused node\n\n    if (event.altKey || event.currentTarget !== event.target || !focusedNodeId) {\n      return;\n    }\n\n    const ctrlPressed = event.ctrlKey || event.metaKey;\n\n    switch (key) {\n      case ' ':\n        if (!disableSelection && !isDisabled(focusedNodeId)) {\n          if (multiSelect && event.shiftKey) {\n            selectRange(event, {\n              end: focusedNodeId\n            });\n            flag = true;\n          } else if (multiSelect) {\n            flag = selectNode(event, focusedNodeId, true);\n          } else {\n            flag = selectNode(event, focusedNodeId);\n          }\n        }\n\n        event.stopPropagation();\n        break;\n\n      case 'Enter':\n        if (!isDisabled(focusedNodeId)) {\n          if (isExpandable(focusedNodeId)) {\n            toggleExpansion(event);\n            flag = true;\n          }\n        }\n\n        event.stopPropagation();\n        break;\n\n      case 'ArrowDown':\n        if (multiSelect && event.shiftKey && !disableSelection) {\n          selectNextNode(event, focusedNodeId);\n        }\n\n        focusNextNode(event, focusedNodeId);\n        flag = true;\n        break;\n\n      case 'ArrowUp':\n        if (multiSelect && event.shiftKey && !disableSelection) {\n          selectPreviousNode(event, focusedNodeId);\n        }\n\n        focusPreviousNode(event, focusedNodeId);\n        flag = true;\n        break;\n\n      case 'ArrowRight':\n        if (isRtl) {\n          flag = handlePreviousArrow(event);\n        } else {\n          flag = handleNextArrow(event);\n        }\n\n        break;\n\n      case 'ArrowLeft':\n        if (isRtl) {\n          flag = handleNextArrow(event);\n        } else {\n          flag = handlePreviousArrow(event);\n        }\n\n        break;\n\n      case 'Home':\n        if (multiSelect && ctrlPressed && event.shiftKey && !disableSelection && !isDisabled(focusedNodeId)) {\n          rangeSelectToFirst(event, focusedNodeId);\n        }\n\n        focusFirstNode(event);\n        flag = true;\n        break;\n\n      case 'End':\n        if (multiSelect && ctrlPressed && event.shiftKey && !disableSelection && !isDisabled(focusedNodeId)) {\n          rangeSelectToLast(event, focusedNodeId);\n        }\n\n        focusLastNode(event);\n        flag = true;\n        break;\n\n      default:\n        if (key === '*') {\n          expandAllSiblings(event, focusedNodeId);\n          flag = true;\n        } else if (multiSelect && ctrlPressed && key.toLowerCase() === 'a' && !disableSelection) {\n          selectAllNodes(event);\n          flag = true;\n        } else if (!ctrlPressed && !event.shiftKey && isPrintableCharacter(key)) {\n          focusByFirstCharacter(event, focusedNodeId, key);\n          flag = true;\n        }\n\n    }\n\n    if (flag) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n\n    if (onKeyDown) {\n      onKeyDown(event);\n    }\n  };\n\n  const handleFocus = event => {\n    // if the event bubbled (which is React specific) we don't want to steal focus\n    if (event.target === event.currentTarget) {\n      const firstSelected = Array.isArray(selected) ? selected[0] : selected;\n      focus(event, firstSelected || getNavigableChildrenIds(null)[0]);\n    }\n\n    if (onFocus) {\n      onFocus(event);\n    }\n  };\n\n  const handleBlur = event => {\n    setFocusedNodeId(null);\n\n    if (onBlur) {\n      onBlur(event);\n    }\n  };\n\n  const activeDescendant = nodeMap.current[focusedNodeId] ? nodeMap.current[focusedNodeId].idAttribute : null;\n  return /*#__PURE__*/_jsx(TreeViewContext.Provider, {\n    value: {\n      icons: {\n        defaultCollapseIcon,\n        defaultExpandIcon,\n        defaultParentIcon,\n        defaultEndIcon\n      },\n      focus,\n      toggleExpansion,\n      isExpanded,\n      isExpandable,\n      isFocused,\n      isSelected,\n      isDisabled,\n      selectNode: disableSelection ? noopSelection : selectNode,\n      selectRange: disableSelection ? noopSelection : selectRange,\n      multiSelect,\n      disabledItemsFocusable,\n      mapFirstChar,\n      unMapFirstChar,\n      registerNode,\n      unregisterNode,\n      treeId\n    },\n    children: /*#__PURE__*/_jsx(DescendantProvider, {\n      children: /*#__PURE__*/_jsx(TreeViewRoot, _extends({\n        role: \"tree\",\n        id: treeId,\n        \"aria-activedescendant\": activeDescendant,\n        \"aria-multiselectable\": multiSelect,\n        className: clsx(classes.root, className),\n        ref: handleRef,\n        tabIndex: 0,\n        onKeyDown: handleKeyDown,\n        onFocus: handleFocus,\n        onBlur: handleBlur,\n        styleProps: styleProps\n      }, other, {\n        children: children\n      }))\n    })\n  });\n});\nprocess.env.NODE_ENV !== \"production\" ? TreeView.propTypes\n/* remove-proptypes */\n= {\n  // ----------------------------- Warning --------------------------------\n  // | These PropTypes are generated from the TypeScript type definitions |\n  // |     To update them edit the d.ts file and run \"yarn proptypes\"     |\n  // ----------------------------------------------------------------------\n\n  /**\n   * The content of the component.\n   */\n  children: PropTypes.node,\n\n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: PropTypes.object,\n\n  /**\n   * @ignore\n   */\n  className: PropTypes.string,\n\n  /**\n   * The default icon used to collapse the node.\n   */\n  defaultCollapseIcon: PropTypes.node,\n\n  /**\n   * The default icon displayed next to a end node. This is applied to all\n   * tree nodes and can be overridden by the TreeItem `icon` prop.\n   */\n  defaultEndIcon: PropTypes.node,\n\n  /**\n   * Expanded node ids. (Uncontrolled)\n   * @default []\n   */\n  defaultExpanded: PropTypes.arrayOf(PropTypes.string),\n\n  /**\n   * The default icon used to expand the node.\n   */\n  defaultExpandIcon: PropTypes.node,\n\n  /**\n   * The default icon displayed next to a parent node. This is applied to all\n   * parent nodes and can be overridden by the TreeItem `icon` prop.\n   */\n  defaultParentIcon: PropTypes.node,\n\n  /**\n   * Selected node ids. (Uncontrolled)\n   * When `multiSelect` is true this takes an array of strings; when false (default) a string.\n   * @default []\n   */\n  defaultSelected: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.string), PropTypes.string]),\n\n  /**\n   * If `true`, will allow focus on disabled items.\n   * @default false\n   */\n  disabledItemsFocusable: PropTypes.bool,\n\n  /**\n   * If `true` selection is disabled.\n   * @default false\n   */\n  disableSelection: PropTypes.bool,\n\n  /**\n   * Expanded node ids. (Controlled)\n   */\n  expanded: PropTypes.arrayOf(PropTypes.string),\n\n  /**\n   * This prop is used to help implement the accessibility logic.\n   * If you don't provide this prop. It falls back to a randomly generated id.\n   */\n  id: PropTypes.string,\n\n  /**\n   * If true `ctrl` and `shift` will trigger multiselect.\n   * @default false\n   */\n  multiSelect: PropTypes.bool,\n\n  /**\n   * @ignore\n   */\n  onBlur: PropTypes.func,\n\n  /**\n   * @ignore\n   */\n  onFocus: PropTypes.func,\n\n  /**\n   * @ignore\n   */\n  onKeyDown: PropTypes.func,\n\n  /**\n   * Callback fired when tree items are focused.\n   *\n   * @param {object} event The event source of the callback **Warning**: This is a generic event not a focus event.\n   * @param {string} value of the focused node.\n   */\n  onNodeFocus: PropTypes.func,\n\n  /**\n   * Callback fired when tree items are selected/unselected.\n   *\n   * @param {object} event The event source of the callback\n   * @param {(array|string)} value of the selected nodes. When `multiSelect` is true\n   * this is an array of strings; when false (default) a string.\n   */\n  onNodeSelect: PropTypes.func,\n\n  /**\n   * Callback fired when tree items are expanded/collapsed.\n   *\n   * @param {object} event The event source of the callback.\n   * @param {array} nodeIds The ids of the expanded nodes.\n   */\n  onNodeToggle: PropTypes.func,\n\n  /**\n   * Selected node ids. (Controlled)\n   * When `multiSelect` is true this takes an array of strings; when false (default) a string.\n   */\n  selected: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.string), PropTypes.string]),\n\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: PropTypes.object\n} : void 0;\nexport default TreeView;","map":{"version":3,"sources":["C:/Users/Usuario/Documents/react/website/node_modules/@material-ui/lab/TreeView/TreeView.js"],"names":["_extends","_objectWithoutPropertiesLoose","React","clsx","PropTypes","experimentalStyled","useTheme","unstable_useThemeProps","useThemeProps","unstable_composeClasses","composeClasses","useControlled","useForkRef","ownerDocument","unstable_useId","useId","TreeViewContext","DescendantProvider","getTreeViewUtilityClass","jsx","_jsx","overridesResolver","props","styles","root","useUtilityClasses","styleProps","classes","slots","TreeViewRoot","name","slot","padding","margin","listStyle","outline","isPrintableCharacter","string","length","match","findNextFirstChar","firstChars","startIndex","char","i","noopSelection","defaultDefaultExpanded","defaultDefaultSelected","TreeView","forwardRef","inProps","ref","children","className","defaultCollapseIcon","defaultEndIcon","defaultExpanded","defaultExpandIcon","defaultParentIcon","defaultSelected","disabledItemsFocusable","disableSelection","expanded","expandedProp","id","idProp","multiSelect","onBlur","onFocus","onKeyDown","onNodeFocus","onNodeSelect","onNodeToggle","selected","selectedProp","other","theme","isRtl","direction","treeId","treeRef","useRef","handleRef","focusedNodeId","setFocusedNodeId","useState","nodeMap","firstCharMap","setExpandedState","controlled","default","state","setSelectedState","isExpanded","useCallback","Array","isArray","indexOf","isExpandable","current","expandable","isSelected","isDisabled","node","disabled","parentId","isFocused","getChildrenIds","Object","keys","map","key","filter","sort","a","b","index","child","getNavigableChildrenIds","childrenIds","getNextNode","siblings","nextSibling","parent","parentSiblings","getPreviousNode","nodeIndex","currentNode","pop","getLastNode","lastNode","getFirstNode","getParent","findOrderInTremauxTree","nodeAId","nodeBId","nodeA","nodeB","aFamily","bFamily","aAncestor","bAncestor","aAncestorIsCommon","bAncestorIsCommon","continueA","continueB","push","commonAncestor","ancestorFamily","aSide","bSide","getNodesInRange","first","last","nodes","focus","event","focusNextNode","focusPreviousNode","focusFirstNode","focusLastNode","focusByFirstCharacter","start","lowercaseChar","toLowerCase","firstCharIds","forEach","nodeId","firstChar","visible","shouldBeSkipped","toggleExpansion","value","newExpanded","concat","expandAllSiblings","diff","lastSelectedNode","lastSelectionWasRange","currentRangeSelection","handleRangeArrowSelect","base","slice","next","handleRangeSelect","end","range","newSelected","handleMultipleSelect","handleSingleSelect","selectNode","multiple","selectRange","stacked","rangeSelectToFirst","rangeSelectToLast","selectNextNode","selectPreviousNode","selectAllNodes","registerNode","idAttribute","unregisterNode","newMap","oldFocusedNodeId","activeElement","mapFirstChar","unMapFirstChar","handleNextArrow","handlePreviousArrow","handleKeyDown","flag","altKey","currentTarget","target","ctrlPressed","ctrlKey","metaKey","shiftKey","stopPropagation","preventDefault","handleFocus","firstSelected","handleBlur","activeDescendant","Provider","icons","role","tabIndex","process","env","NODE_ENV","propTypes","object","arrayOf","oneOfType","bool","func","sx"],"mappings":"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","sourcesContent":["import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nimport * as React from 'react';\nimport clsx from 'clsx';\nimport PropTypes from 'prop-types';\nimport { experimentalStyled, useTheme, unstable_useThemeProps as useThemeProps } from '@material-ui/core/styles';\nimport { unstable_composeClasses as composeClasses } from '@material-ui/unstyled';\nimport { useControlled, useForkRef, ownerDocument, unstable_useId as useId } from '@material-ui/core/utils';\nimport TreeViewContext from './TreeViewContext';\nimport { DescendantProvider } from './descendants';\nimport { getTreeViewUtilityClass } from './treeViewClasses';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\n\nconst overridesResolver = (props, styles) => styles.root || {};\n\nconst useUtilityClasses = styleProps => {\n  const {\n    classes\n  } = styleProps;\n  const slots = {\n    root: ['root']\n  };\n  return composeClasses(slots, getTreeViewUtilityClass, classes);\n};\n\nconst TreeViewRoot = experimentalStyled('ul', {}, {\n  name: 'MuiTreeView',\n  slot: 'Root',\n  overridesResolver\n})({\n  padding: 0,\n  margin: 0,\n  listStyle: 'none',\n  outline: 0\n});\n\nfunction isPrintableCharacter(string) {\n  return string && string.length === 1 && string.match(/\\S/);\n}\n\nfunction findNextFirstChar(firstChars, startIndex, char) {\n  for (let i = startIndex; i < firstChars.length; i += 1) {\n    if (char === firstChars[i]) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\nfunction noopSelection() {\n  return false;\n}\n\nconst defaultDefaultExpanded = [];\nconst defaultDefaultSelected = [];\nconst TreeView = /*#__PURE__*/React.forwardRef(function TreeView(inProps, ref) {\n  const props = useThemeProps({\n    props: inProps,\n    name: 'MuiTreeView'\n  });\n\n  const {\n    children,\n    className,\n    defaultCollapseIcon,\n    defaultEndIcon,\n    defaultExpanded = defaultDefaultExpanded,\n    defaultExpandIcon,\n    defaultParentIcon,\n    defaultSelected = defaultDefaultSelected,\n    disabledItemsFocusable = false,\n    disableSelection = false,\n    expanded: expandedProp,\n    id: idProp,\n    multiSelect = false,\n    onBlur,\n    onFocus,\n    onKeyDown,\n    onNodeFocus,\n    onNodeSelect,\n    onNodeToggle,\n    selected: selectedProp\n  } = props,\n        other = _objectWithoutPropertiesLoose(props, [\"children\", \"className\", \"defaultCollapseIcon\", \"defaultEndIcon\", \"defaultExpanded\", \"defaultExpandIcon\", \"defaultParentIcon\", \"defaultSelected\", \"disabledItemsFocusable\", \"disableSelection\", \"expanded\", \"id\", \"multiSelect\", \"onBlur\", \"onFocus\", \"onKeyDown\", \"onNodeFocus\", \"onNodeSelect\", \"onNodeToggle\", \"selected\"]); // use the `isRtl` from the props after the buildAPI script support it\n\n\n  const theme = useTheme();\n  const isRtl = theme.direction === 'rtl';\n\n  const styleProps = _extends({}, props, {\n    defaultExpanded,\n    defaultSelected,\n    disabledItemsFocusable,\n    disableSelection,\n    multiSelect\n  });\n\n  const classes = useUtilityClasses(styleProps);\n  const treeId = useId(idProp);\n  const treeRef = React.useRef(null);\n  const handleRef = useForkRef(treeRef, ref);\n  const [focusedNodeId, setFocusedNodeId] = React.useState(null);\n  const nodeMap = React.useRef({});\n  const firstCharMap = React.useRef({});\n  const [expanded, setExpandedState] = useControlled({\n    controlled: expandedProp,\n    default: defaultExpanded,\n    name: 'TreeView',\n    state: 'expanded'\n  });\n  const [selected, setSelectedState] = useControlled({\n    controlled: selectedProp,\n    default: defaultSelected,\n    name: 'TreeView',\n    state: 'selected'\n  });\n  /*\n   * Status Helpers\n   */\n\n  const isExpanded = React.useCallback(id => Array.isArray(expanded) ? expanded.indexOf(id) !== -1 : false, [expanded]);\n  const isExpandable = React.useCallback(id => nodeMap.current[id] && nodeMap.current[id].expandable, []);\n  const isSelected = React.useCallback(id => Array.isArray(selected) ? selected.indexOf(id) !== -1 : selected === id, [selected]);\n  const isDisabled = React.useCallback(id => {\n    let node = nodeMap.current[id]; // This can be called before the node has been added to the node map.\n\n    if (!node) {\n      return false;\n    }\n\n    if (node.disabled) {\n      return true;\n    }\n\n    while (node.parentId != null) {\n      node = nodeMap.current[node.parentId];\n\n      if (node.disabled) {\n        return true;\n      }\n    }\n\n    return false;\n  }, []);\n\n  const isFocused = id => focusedNodeId === id;\n  /*\n   * Child Helpers\n   */\n  // Using Object.keys -> .map to mimic Object.values we should replace with Object.values() once we stop IE11 support.\n\n\n  const getChildrenIds = id => Object.keys(nodeMap.current).map(key => {\n    return nodeMap.current[key];\n  }).filter(node => node.parentId === id).sort((a, b) => a.index - b.index).map(child => child.id);\n\n  const getNavigableChildrenIds = id => {\n    let childrenIds = getChildrenIds(id);\n\n    if (!disabledItemsFocusable) {\n      childrenIds = childrenIds.filter(node => !isDisabled(node));\n    }\n\n    return childrenIds;\n  };\n  /*\n   * Node Helpers\n   */\n\n\n  const getNextNode = id => {\n    // If expanded get first child\n    if (isExpanded(id) && getNavigableChildrenIds(id).length > 0) {\n      return getNavigableChildrenIds(id)[0];\n    } // Try to get next sibling\n\n\n    const node = nodeMap.current[id];\n    const siblings = getNavigableChildrenIds(node.parentId);\n    const nextSibling = siblings[siblings.indexOf(id) + 1];\n\n    if (nextSibling) {\n      return nextSibling;\n    } // try to get parent's next sibling\n\n\n    const parent = nodeMap.current[node.parentId];\n\n    if (parent) {\n      const parentSiblings = getNavigableChildrenIds(parent.parentId);\n      return parentSiblings[parentSiblings.indexOf(parent.id) + 1];\n    }\n\n    return null;\n  };\n\n  const getPreviousNode = id => {\n    const node = nodeMap.current[id];\n    const siblings = getNavigableChildrenIds(node.parentId);\n    const nodeIndex = siblings.indexOf(id);\n\n    if (nodeIndex === 0) {\n      return node.parentId;\n    }\n\n    let currentNode = siblings[nodeIndex - 1];\n\n    while (isExpanded(currentNode) && getNavigableChildrenIds(currentNode).length > 0) {\n      currentNode = getNavigableChildrenIds(currentNode).pop();\n    }\n\n    return currentNode;\n  };\n\n  const getLastNode = () => {\n    let lastNode = getNavigableChildrenIds(null).pop();\n\n    while (isExpanded(lastNode)) {\n      lastNode = getNavigableChildrenIds(lastNode).pop();\n    }\n\n    return lastNode;\n  };\n\n  const getFirstNode = () => getNavigableChildrenIds(null)[0];\n\n  const getParent = id => nodeMap.current[id].parentId;\n  /**\n   * This is used to determine the start and end of a selection range so\n   * we can get the nodes between the two border nodes.\n   *\n   * It finds the nodes' common ancestor using\n   * a naive implementation of a lowest common ancestor algorithm\n   * (https://en.wikipedia.org/wiki/Lowest_common_ancestor).\n   * Then compares the ancestor's 2 children that are ancestors of nodeA and NodeB\n   * so we can compare their indexes to work out which node comes first in a depth first search.\n   * (https://en.wikipedia.org/wiki/Depth-first_search)\n   *\n   * Another way to put it is which node is shallower in a trÃ©maux tree\n   * https://en.wikipedia.org/wiki/Tr%C3%A9maux_tree\n   */\n\n\n  const findOrderInTremauxTree = (nodeAId, nodeBId) => {\n    if (nodeAId === nodeBId) {\n      return [nodeAId, nodeBId];\n    }\n\n    const nodeA = nodeMap.current[nodeAId];\n    const nodeB = nodeMap.current[nodeBId];\n\n    if (nodeA.parentId === nodeB.id || nodeB.parentId === nodeA.id) {\n      return nodeB.parentId === nodeA.id ? [nodeA.id, nodeB.id] : [nodeB.id, nodeA.id];\n    }\n\n    const aFamily = [nodeA.id];\n    const bFamily = [nodeB.id];\n    let aAncestor = nodeA.parentId;\n    let bAncestor = nodeB.parentId;\n    let aAncestorIsCommon = bFamily.indexOf(aAncestor) !== -1;\n    let bAncestorIsCommon = aFamily.indexOf(bAncestor) !== -1;\n    let continueA = true;\n    let continueB = true;\n\n    while (!bAncestorIsCommon && !aAncestorIsCommon) {\n      if (continueA) {\n        aFamily.push(aAncestor);\n        aAncestorIsCommon = bFamily.indexOf(aAncestor) !== -1;\n        continueA = aAncestor !== null;\n\n        if (!aAncestorIsCommon && continueA) {\n          aAncestor = nodeMap.current[aAncestor].parentId;\n        }\n      }\n\n      if (continueB && !aAncestorIsCommon) {\n        bFamily.push(bAncestor);\n        bAncestorIsCommon = aFamily.indexOf(bAncestor) !== -1;\n        continueB = bAncestor !== null;\n\n        if (!bAncestorIsCommon && continueB) {\n          bAncestor = nodeMap.current[bAncestor].parentId;\n        }\n      }\n    }\n\n    const commonAncestor = aAncestorIsCommon ? aAncestor : bAncestor;\n    const ancestorFamily = getChildrenIds(commonAncestor);\n    const aSide = aFamily[aFamily.indexOf(commonAncestor) - 1];\n    const bSide = bFamily[bFamily.indexOf(commonAncestor) - 1];\n    return ancestorFamily.indexOf(aSide) < ancestorFamily.indexOf(bSide) ? [nodeAId, nodeBId] : [nodeBId, nodeAId];\n  };\n\n  const getNodesInRange = (nodeA, nodeB) => {\n    const [first, last] = findOrderInTremauxTree(nodeA, nodeB);\n    const nodes = [first];\n    let current = first;\n\n    while (current !== last) {\n      current = getNextNode(current);\n      nodes.push(current);\n    }\n\n    return nodes;\n  };\n  /*\n   * Focus Helpers\n   */\n\n\n  const focus = (event, id) => {\n    if (id) {\n      setFocusedNodeId(id);\n\n      if (onNodeFocus) {\n        onNodeFocus(event, id);\n      }\n    }\n  };\n\n  const focusNextNode = (event, id) => focus(event, getNextNode(id));\n\n  const focusPreviousNode = (event, id) => focus(event, getPreviousNode(id));\n\n  const focusFirstNode = event => focus(event, getFirstNode());\n\n  const focusLastNode = event => focus(event, getLastNode());\n\n  const focusByFirstCharacter = (event, id, char) => {\n    let start;\n    let index;\n    const lowercaseChar = char.toLowerCase();\n    const firstCharIds = [];\n    const firstChars = []; // This really only works since the ids are strings\n\n    Object.keys(firstCharMap.current).forEach(nodeId => {\n      const firstChar = firstCharMap.current[nodeId];\n      const map = nodeMap.current[nodeId];\n      const visible = map.parentId ? isExpanded(map.parentId) : true;\n      const shouldBeSkipped = disabledItemsFocusable ? false : isDisabled(nodeId);\n\n      if (visible && !shouldBeSkipped) {\n        firstCharIds.push(nodeId);\n        firstChars.push(firstChar);\n      }\n    }); // Get start index for search based on position of currentItem\n\n    start = firstCharIds.indexOf(id) + 1;\n\n    if (start >= firstCharIds.length) {\n      start = 0;\n    } // Check remaining slots in the menu\n\n\n    index = findNextFirstChar(firstChars, start, lowercaseChar); // If not found in remaining slots, check from beginning\n\n    if (index === -1) {\n      index = findNextFirstChar(firstChars, 0, lowercaseChar);\n    } // If match was found...\n\n\n    if (index > -1) {\n      focus(event, firstCharIds[index]);\n    }\n  };\n  /*\n   * Expansion Helpers\n   */\n\n\n  const toggleExpansion = (event, value = focusedNodeId) => {\n    let newExpanded;\n\n    if (expanded.indexOf(value) !== -1) {\n      newExpanded = expanded.filter(id => id !== value);\n    } else {\n      newExpanded = [value].concat(expanded);\n    }\n\n    if (onNodeToggle) {\n      onNodeToggle(event, newExpanded);\n    }\n\n    setExpandedState(newExpanded);\n  };\n\n  const expandAllSiblings = (event, id) => {\n    const map = nodeMap.current[id];\n    const siblings = getChildrenIds(map.parentId);\n    const diff = siblings.filter(child => isExpandable(child) && !isExpanded(child));\n    const newExpanded = expanded.concat(diff);\n\n    if (diff.length > 0) {\n      setExpandedState(newExpanded);\n\n      if (onNodeToggle) {\n        onNodeToggle(event, newExpanded);\n      }\n    }\n  };\n  /*\n   * Selection Helpers\n   */\n\n\n  const lastSelectedNode = React.useRef(null);\n  const lastSelectionWasRange = React.useRef(false);\n  const currentRangeSelection = React.useRef([]);\n\n  const handleRangeArrowSelect = (event, nodes) => {\n    let base = selected.slice();\n    const {\n      start,\n      next,\n      current\n    } = nodes;\n\n    if (!next || !current) {\n      return;\n    }\n\n    if (currentRangeSelection.current.indexOf(current) === -1) {\n      currentRangeSelection.current = [];\n    }\n\n    if (lastSelectionWasRange.current) {\n      if (currentRangeSelection.current.indexOf(next) !== -1) {\n        base = base.filter(id => id === start || id !== current);\n        currentRangeSelection.current = currentRangeSelection.current.filter(id => id === start || id !== current);\n      } else {\n        base.push(next);\n        currentRangeSelection.current.push(next);\n      }\n    } else {\n      base.push(next);\n      currentRangeSelection.current.push(current, next);\n    }\n\n    if (onNodeSelect) {\n      onNodeSelect(event, base);\n    }\n\n    setSelectedState(base);\n  };\n\n  const handleRangeSelect = (event, nodes) => {\n    let base = selected.slice();\n    const {\n      start,\n      end\n    } = nodes; // If last selection was a range selection ignore nodes that were selected.\n\n    if (lastSelectionWasRange.current) {\n      base = base.filter(id => currentRangeSelection.current.indexOf(id) === -1);\n    }\n\n    let range = getNodesInRange(start, end);\n    range = range.filter(node => !isDisabled(node));\n    currentRangeSelection.current = range;\n    let newSelected = base.concat(range);\n    newSelected = newSelected.filter((id, i) => newSelected.indexOf(id) === i);\n\n    if (onNodeSelect) {\n      onNodeSelect(event, newSelected);\n    }\n\n    setSelectedState(newSelected);\n  };\n\n  const handleMultipleSelect = (event, value) => {\n    let newSelected;\n\n    if (selected.indexOf(value) !== -1) {\n      newSelected = selected.filter(id => id !== value);\n    } else {\n      newSelected = [value].concat(selected);\n    }\n\n    if (onNodeSelect) {\n      onNodeSelect(event, newSelected);\n    }\n\n    setSelectedState(newSelected);\n  };\n\n  const handleSingleSelect = (event, value) => {\n    const newSelected = multiSelect ? [value] : value;\n\n    if (onNodeSelect) {\n      onNodeSelect(event, newSelected);\n    }\n\n    setSelectedState(newSelected);\n  };\n\n  const selectNode = (event, id, multiple = false) => {\n    if (id) {\n      if (multiple) {\n        handleMultipleSelect(event, id);\n      } else {\n        handleSingleSelect(event, id);\n      }\n\n      lastSelectedNode.current = id;\n      lastSelectionWasRange.current = false;\n      currentRangeSelection.current = [];\n      return true;\n    }\n\n    return false;\n  };\n\n  const selectRange = (event, nodes, stacked = false) => {\n    const {\n      start = lastSelectedNode.current,\n      end,\n      current\n    } = nodes;\n\n    if (stacked) {\n      handleRangeArrowSelect(event, {\n        start,\n        next: end,\n        current\n      });\n    } else if (start != null && end != null) {\n      handleRangeSelect(event, {\n        start,\n        end\n      });\n    }\n\n    lastSelectionWasRange.current = true;\n  };\n\n  const rangeSelectToFirst = (event, id) => {\n    if (!lastSelectedNode.current) {\n      lastSelectedNode.current = id;\n    }\n\n    const start = lastSelectionWasRange.current ? lastSelectedNode.current : id;\n    selectRange(event, {\n      start,\n      end: getFirstNode()\n    });\n  };\n\n  const rangeSelectToLast = (event, id) => {\n    if (!lastSelectedNode.current) {\n      lastSelectedNode.current = id;\n    }\n\n    const start = lastSelectionWasRange.current ? lastSelectedNode.current : id;\n    selectRange(event, {\n      start,\n      end: getLastNode()\n    });\n  };\n\n  const selectNextNode = (event, id) => {\n    if (!isDisabled(getNextNode(id))) {\n      selectRange(event, {\n        end: getNextNode(id),\n        current: id\n      }, true);\n    }\n  };\n\n  const selectPreviousNode = (event, id) => {\n    if (!isDisabled(getPreviousNode(id))) {\n      selectRange(event, {\n        end: getPreviousNode(id),\n        current: id\n      }, true);\n    }\n  };\n\n  const selectAllNodes = event => {\n    selectRange(event, {\n      start: getFirstNode(),\n      end: getLastNode()\n    });\n  };\n  /*\n   * Mapping Helpers\n   */\n\n\n  const registerNode = React.useCallback(node => {\n    const {\n      id,\n      index,\n      parentId,\n      expandable,\n      idAttribute,\n      disabled\n    } = node;\n    nodeMap.current[id] = {\n      id,\n      index,\n      parentId,\n      expandable,\n      idAttribute,\n      disabled\n    };\n  }, []);\n  const unregisterNode = React.useCallback(id => {\n    const newMap = _extends({}, nodeMap.current);\n\n    delete newMap[id];\n    nodeMap.current = newMap;\n    setFocusedNodeId(oldFocusedNodeId => {\n      if (oldFocusedNodeId === id && treeRef.current === ownerDocument(treeRef.current).activeElement) {\n        return getChildrenIds(null)[0];\n      }\n\n      return oldFocusedNodeId;\n    });\n  }, []);\n  const mapFirstChar = React.useCallback((id, firstChar) => {\n    firstCharMap.current[id] = firstChar;\n  }, []);\n  const unMapFirstChar = React.useCallback(id => {\n    const newMap = _extends({}, firstCharMap.current);\n\n    delete newMap[id];\n    firstCharMap.current = newMap;\n  }, []);\n  /**\n   * Event handlers and Navigation\n   */\n\n  const handleNextArrow = event => {\n    if (isExpandable(focusedNodeId)) {\n      if (isExpanded(focusedNodeId)) {\n        focusNextNode(event, focusedNodeId);\n      } else if (!isDisabled(focusedNodeId)) {\n        toggleExpansion(event);\n      }\n    }\n\n    return true;\n  };\n\n  const handlePreviousArrow = event => {\n    if (isExpanded(focusedNodeId) && !isDisabled(focusedNodeId)) {\n      toggleExpansion(event, focusedNodeId);\n      return true;\n    }\n\n    const parent = getParent(focusedNodeId);\n\n    if (parent) {\n      focus(event, parent);\n      return true;\n    }\n\n    return false;\n  };\n\n  const handleKeyDown = event => {\n    let flag = false;\n    const key = event.key; // If the tree is empty there will be no focused node\n\n    if (event.altKey || event.currentTarget !== event.target || !focusedNodeId) {\n      return;\n    }\n\n    const ctrlPressed = event.ctrlKey || event.metaKey;\n\n    switch (key) {\n      case ' ':\n        if (!disableSelection && !isDisabled(focusedNodeId)) {\n          if (multiSelect && event.shiftKey) {\n            selectRange(event, {\n              end: focusedNodeId\n            });\n            flag = true;\n          } else if (multiSelect) {\n            flag = selectNode(event, focusedNodeId, true);\n          } else {\n            flag = selectNode(event, focusedNodeId);\n          }\n        }\n\n        event.stopPropagation();\n        break;\n\n      case 'Enter':\n        if (!isDisabled(focusedNodeId)) {\n          if (isExpandable(focusedNodeId)) {\n            toggleExpansion(event);\n            flag = true;\n          }\n        }\n\n        event.stopPropagation();\n        break;\n\n      case 'ArrowDown':\n        if (multiSelect && event.shiftKey && !disableSelection) {\n          selectNextNode(event, focusedNodeId);\n        }\n\n        focusNextNode(event, focusedNodeId);\n        flag = true;\n        break;\n\n      case 'ArrowUp':\n        if (multiSelect && event.shiftKey && !disableSelection) {\n          selectPreviousNode(event, focusedNodeId);\n        }\n\n        focusPreviousNode(event, focusedNodeId);\n        flag = true;\n        break;\n\n      case 'ArrowRight':\n        if (isRtl) {\n          flag = handlePreviousArrow(event);\n        } else {\n          flag = handleNextArrow(event);\n        }\n\n        break;\n\n      case 'ArrowLeft':\n        if (isRtl) {\n          flag = handleNextArrow(event);\n        } else {\n          flag = handlePreviousArrow(event);\n        }\n\n        break;\n\n      case 'Home':\n        if (multiSelect && ctrlPressed && event.shiftKey && !disableSelection && !isDisabled(focusedNodeId)) {\n          rangeSelectToFirst(event, focusedNodeId);\n        }\n\n        focusFirstNode(event);\n        flag = true;\n        break;\n\n      case 'End':\n        if (multiSelect && ctrlPressed && event.shiftKey && !disableSelection && !isDisabled(focusedNodeId)) {\n          rangeSelectToLast(event, focusedNodeId);\n        }\n\n        focusLastNode(event);\n        flag = true;\n        break;\n\n      default:\n        if (key === '*') {\n          expandAllSiblings(event, focusedNodeId);\n          flag = true;\n        } else if (multiSelect && ctrlPressed && key.toLowerCase() === 'a' && !disableSelection) {\n          selectAllNodes(event);\n          flag = true;\n        } else if (!ctrlPressed && !event.shiftKey && isPrintableCharacter(key)) {\n          focusByFirstCharacter(event, focusedNodeId, key);\n          flag = true;\n        }\n\n    }\n\n    if (flag) {\n      event.preventDefault();\n      event.stopPropagation();\n    }\n\n    if (onKeyDown) {\n      onKeyDown(event);\n    }\n  };\n\n  const handleFocus = event => {\n    // if the event bubbled (which is React specific) we don't want to steal focus\n    if (event.target === event.currentTarget) {\n      const firstSelected = Array.isArray(selected) ? selected[0] : selected;\n      focus(event, firstSelected || getNavigableChildrenIds(null)[0]);\n    }\n\n    if (onFocus) {\n      onFocus(event);\n    }\n  };\n\n  const handleBlur = event => {\n    setFocusedNodeId(null);\n\n    if (onBlur) {\n      onBlur(event);\n    }\n  };\n\n  const activeDescendant = nodeMap.current[focusedNodeId] ? nodeMap.current[focusedNodeId].idAttribute : null;\n  return /*#__PURE__*/_jsx(TreeViewContext.Provider, {\n    value: {\n      icons: {\n        defaultCollapseIcon,\n        defaultExpandIcon,\n        defaultParentIcon,\n        defaultEndIcon\n      },\n      focus,\n      toggleExpansion,\n      isExpanded,\n      isExpandable,\n      isFocused,\n      isSelected,\n      isDisabled,\n      selectNode: disableSelection ? noopSelection : selectNode,\n      selectRange: disableSelection ? noopSelection : selectRange,\n      multiSelect,\n      disabledItemsFocusable,\n      mapFirstChar,\n      unMapFirstChar,\n      registerNode,\n      unregisterNode,\n      treeId\n    },\n    children: /*#__PURE__*/_jsx(DescendantProvider, {\n      children: /*#__PURE__*/_jsx(TreeViewRoot, _extends({\n        role: \"tree\",\n        id: treeId,\n        \"aria-activedescendant\": activeDescendant,\n        \"aria-multiselectable\": multiSelect,\n        className: clsx(classes.root, className),\n        ref: handleRef,\n        tabIndex: 0,\n        onKeyDown: handleKeyDown,\n        onFocus: handleFocus,\n        onBlur: handleBlur,\n        styleProps: styleProps\n      }, other, {\n        children: children\n      }))\n    })\n  });\n});\nprocess.env.NODE_ENV !== \"production\" ? TreeView.propTypes\n/* remove-proptypes */\n= {\n  // ----------------------------- Warning --------------------------------\n  // | These PropTypes are generated from the TypeScript type definitions |\n  // |     To update them edit the d.ts file and run \"yarn proptypes\"     |\n  // ----------------------------------------------------------------------\n\n  /**\n   * The content of the component.\n   */\n  children: PropTypes.node,\n\n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: PropTypes.object,\n\n  /**\n   * @ignore\n   */\n  className: PropTypes.string,\n\n  /**\n   * The default icon used to collapse the node.\n   */\n  defaultCollapseIcon: PropTypes.node,\n\n  /**\n   * The default icon displayed next to a end node. This is applied to all\n   * tree nodes and can be overridden by the TreeItem `icon` prop.\n   */\n  defaultEndIcon: PropTypes.node,\n\n  /**\n   * Expanded node ids. (Uncontrolled)\n   * @default []\n   */\n  defaultExpanded: PropTypes.arrayOf(PropTypes.string),\n\n  /**\n   * The default icon used to expand the node.\n   */\n  defaultExpandIcon: PropTypes.node,\n\n  /**\n   * The default icon displayed next to a parent node. This is applied to all\n   * parent nodes and can be overridden by the TreeItem `icon` prop.\n   */\n  defaultParentIcon: PropTypes.node,\n\n  /**\n   * Selected node ids. (Uncontrolled)\n   * When `multiSelect` is true this takes an array of strings; when false (default) a string.\n   * @default []\n   */\n  defaultSelected: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.string), PropTypes.string]),\n\n  /**\n   * If `true`, will allow focus on disabled items.\n   * @default false\n   */\n  disabledItemsFocusable: PropTypes.bool,\n\n  /**\n   * If `true` selection is disabled.\n   * @default false\n   */\n  disableSelection: PropTypes.bool,\n\n  /**\n   * Expanded node ids. (Controlled)\n   */\n  expanded: PropTypes.arrayOf(PropTypes.string),\n\n  /**\n   * This prop is used to help implement the accessibility logic.\n   * If you don't provide this prop. It falls back to a randomly generated id.\n   */\n  id: PropTypes.string,\n\n  /**\n   * If true `ctrl` and `shift` will trigger multiselect.\n   * @default false\n   */\n  multiSelect: PropTypes.bool,\n\n  /**\n   * @ignore\n   */\n  onBlur: PropTypes.func,\n\n  /**\n   * @ignore\n   */\n  onFocus: PropTypes.func,\n\n  /**\n   * @ignore\n   */\n  onKeyDown: PropTypes.func,\n\n  /**\n   * Callback fired when tree items are focused.\n   *\n   * @param {object} event The event source of the callback **Warning**: This is a generic event not a focus event.\n   * @param {string} value of the focused node.\n   */\n  onNodeFocus: PropTypes.func,\n\n  /**\n   * Callback fired when tree items are selected/unselected.\n   *\n   * @param {object} event The event source of the callback\n   * @param {(array|string)} value of the selected nodes. When `multiSelect` is true\n   * this is an array of strings; when false (default) a string.\n   */\n  onNodeSelect: PropTypes.func,\n\n  /**\n   * Callback fired when tree items are expanded/collapsed.\n   *\n   * @param {object} event The event source of the callback.\n   * @param {array} nodeIds The ids of the expanded nodes.\n   */\n  onNodeToggle: PropTypes.func,\n\n  /**\n   * Selected node ids. (Controlled)\n   * When `multiSelect` is true this takes an array of strings; when false (default) a string.\n   */\n  selected: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.string), PropTypes.string]),\n\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: PropTypes.object\n} : void 0;\nexport default TreeView;"]},"metadata":{},"sourceType":"module"}